/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { DOCUMENT } from '@angular/common';
import { HttpClient, HttpBackend } from '@angular/common/http';
import { Optional, Inject, RendererFactory2 } from '@angular/core';
import { of as observableOf } from 'rxjs';
import { catchError, map, share, tap } from 'rxjs/operators';
import { getSecondaryColor, withSuffix, isIconDefinition, printErr, printWarn, cloneSVG, withSuffixAndColor, getIconDefinitionFromAbbr, replaceFillColor } from '../utils';
/**
 * @record
 */
export function ReqIconTask() { }
if (false) {
    /** @type {?} */
    ReqIconTask.prototype.ob;
}
var IconService = /** @class */ (function () {
    function IconService(_rendererFactory, _handler, _document) {
        this._rendererFactory = _rendererFactory;
        this._handler = _handler;
        this._document = _document;
        this.defaultTheme = 'outline';
        /**
         * Register icons.
         */
        this._svgDefinitions = new Map();
        /**
         * Register rendered (with color) SVG icons.
         */
        this._svgCachedDefinitions = new Map();
        /**
         * Default color settings.
         */
        this._twoToneColorPalette = {
            primaryColor: '#333333',
            secondaryColor: '#E6E6E6'
        };
        /**
         * A url prefix so users can determine a static asset root.
         */
        this._assetsSource = '';
        /**
         * To note whether a request to an icon is under processing.
         */
        this._httpQueue = new Map();
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
    }
    Object.defineProperty(IconService.prototype, "twoToneColor", {
        get: /**
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (tslib_1.__assign({}, this._twoToneColorPalette))); // Make a copy to avoid unexpected changes.
        },
        set: /**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var primaryColor = _a.primaryColor, secondaryColor = _a.secondaryColor;
            if (primaryColor && typeof primaryColor === 'string' && typeof secondaryColor === 'string' || typeof secondaryColor === 'undefined') {
                this._twoToneColorPalette.primaryColor = primaryColor;
                this._twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} prefix
     * @return {?}
     */
    IconService.prototype.changeAssetsSource = /**
     * @param {?} prefix
     * @return {?}
     */
    function (prefix) {
        this._assetsSource = prefix.endsWith('/') ? prefix : prefix + '/';
    };
    /**
     * Register IconDefinition provided by Ant Design, parsing AbstractNode to svg string.
     * @param icons
     */
    /**
     * Register IconDefinition provided by Ant Design, parsing AbstractNode to svg string.
     * @param {...?} icons
     * @return {?}
     */
    IconService.prototype.addIcon = /**
     * Register IconDefinition provided by Ant Design, parsing AbstractNode to svg string.
     * @param {...?} icons
     * @return {?}
     */
    function () {
        var icons = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            icons[_i] = arguments[_i];
        }
        this._addIconLiteral.apply(this, tslib_1.__spread(icons));
    };
    /**
     * Register icon.
     * @param icons Icons that users want to use in their projects. User defined icons and predefined
     *   icons provided by ant-design should implement IconDefinition both.
     */
    /**
     * Register icon.
     * @param {...?} icons Icons that users want to use in their projects. User defined icons and predefined
     *   icons provided by ant-design should implement IconDefinition both.
     * @return {?}
     */
    IconService.prototype._addIconLiteral = /**
     * Register icon.
     * @param {...?} icons Icons that users want to use in their projects. User defined icons and predefined
     *   icons provided by ant-design should implement IconDefinition both.
     * @return {?}
     */
    function () {
        var _this = this;
        var icons = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            icons[_i] = arguments[_i];
        }
        icons.forEach(function (icon) {
            _this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        });
    };
    /**
     * @param {?} key
     * @return {?}
     */
    IconService.prototype._get = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this._svgDefinitions.get(key) || null;
    };
    /**
     * Get an static file and return it as a string, create a IconDefinition and cache it or return null.
     */
    /**
     * Get an static file and return it as a string, create a IconDefinition and cache it or return null.
     * @param {?} url
     * @return {?}
     */
    IconService.prototype._getFromRemote = /**
     * Get an static file and return it as a string, create a IconDefinition and cache it or return null.
     * @param {?} url
     * @return {?}
     */
    function (url) {
        if (this._http) {
            /** @type {?} */
            var task = this._httpQueue.get(url);
            /** @type {?} */
            var ob = void 0;
            if (task) {
                ob = task.ob;
            }
            else {
                ob = this._createObservableRequest(url);
                task = { ob: ob };
                this._httpQueue.set(url, task);
            }
            return ob;
        }
        else {
            printWarn('You need to import HttpClient module to use dynamic importing');
            return observableOf(null);
        }
    };
    /**
     * @param {?} url
     * @return {?}
     */
    IconService.prototype._createObservableRequest = /**
     * @param {?} url
     * @return {?}
     */
    function (url) {
        var _this = this;
        /** @type {?} */
        var icon = getIconDefinitionFromAbbr(url);
        return this._http.get(this._assetsSource + "assets/" + icon.theme + "/" + icon.name + ".svg", { responseType: 'text' }).pipe(share(), // Use `share` so if multi directives request the same icon, HTTP request would only be fired once.
        tap(function () { return _this._httpQueue.delete(url); }), map(function (svgString) {
            icon.icon = svgString;
            _this._addIconLiteral(icon);
            return icon;
        }), catchError(function () {
            printErr("the icon " + url + " does not exist in your assets folder");
            _this._httpQueue.delete(url);
            return observableOf(null);
        }));
    };
    /**
     * Icon component would call this method to get a SVG element.
     * This method returns a Observable SVG element because when user wants to get an icon dynamically, that would be async,
     * so we provided a unified interface here.
     */
    /**
     * Icon component would call this method to get a SVG element.
     * This method returns a Observable SVG element because when user wants to get an icon dynamically, that would be async,
     * so we provided a unified interface here.
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    IconService.prototype.getRenderedContent = /**
     * Icon component would call this method to get a SVG element.
     * This method returns a Observable SVG element because when user wants to get an icon dynamically, that would be async,
     * so we provided a unified interface here.
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    function (icon, twoToneColor) {
        var _this = this;
        /** @type {?} */
        var definitionOrNull = isIconDefinition(icon)
            ? (/** @type {?} */ (icon))
            : this._get((/** @type {?} */ (icon)));
        /** @type {?} */
        var $icon = definitionOrNull ? observableOf(definitionOrNull) : this._getFromRemote((/** @type {?} */ (icon)));
        return $icon.pipe(map(function (i) {
            if (i) {
                return _this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
            }
            else {
                printErr("the icon " + icon + " does not exist or is not registered");
                return null;
            }
        }));
    };
    /**
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    IconService.prototype._loadSVGFromCacheOrCreateNew = /**
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    function (icon, twoToneColor) {
        /** @type {?} */
        var svg;
        /** @type {?} */
        var pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        /** @type {?} */
        var sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        /** @type {?} */
        var key = withSuffixAndColor(icon.name, icon.theme, pri, sec);
        /** @type {?} */
        var cached = this._svgCachedDefinitions.get(key);
        // If this icon is used before, there should be a copy in cachedDefinitions, just copy it.
        // Otherwise, generate one from string or SVG element, and cache it.
        if (!cached) {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(typeof icon.icon === 'string' ? this._createSVGElementFromString(icon.icon) : icon.icon, icon.theme === 'twotone', pri, sec));
            this._svgCachedDefinitions.set(key, (/** @type {?} */ (tslib_1.__assign({}, icon, { icon: svg }))));
        }
        else {
            svg = cached.icon;
        }
        return cloneSVG(svg);
    };
    /**
     * @param {?} str
     * @return {?}
     */
    IconService.prototype._createSVGElementFromString = /**
     * @param {?} str
     * @return {?}
     */
    function (str) {
        /** @type {?} */
        var colorParsed = replaceFillColor(str);
        /** @type {?} */
        var div = this._document.createElement('div');
        div.innerHTML = colorParsed;
        /** @type {?} */
        var svg = div.querySelector('svg');
        if (!svg) {
            throw Error('<svg> tag not found');
        }
        return svg;
    };
    /**
     * @param {?} svg
     * @return {?}
     */
    IconService.prototype._setSVGAttribute = /**
     * @param {?} svg
     * @return {?}
     */
    function (svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    };
    /**
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    IconService.prototype._colorizeSVGIcon = /**
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    function (svg, twotone, pri, sec) {
        if (twotone) {
            /** @type {?} */
            var children = svg.childNodes;
            /** @type {?} */
            var length_1 = children.length;
            for (var i = 0; i < length_1; i++) {
                /** @type {?} */
                var child = (/** @type {?} */ (children[i]));
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    };
    /**
     * @return {?}
     */
    IconService.prototype.clear = /**
     * @return {?}
     */
    function () {
        this._svgDefinitions.clear();
    };
    IconService.ctorParameters = function () { return [
        { type: RendererFactory2 },
        { type: HttpBackend, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
    ]; };
    return IconService;
}());
export { IconService };
if (false) {
    /** @type {?} */
    IconService.prototype.defaultTheme;
    /** @type {?} */
    IconService.prototype._renderer;
    /** @type {?} */
    IconService.prototype._http;
    /**
     * Register icons.
     * @type {?}
     */
    IconService.prototype._svgDefinitions;
    /**
     * Register rendered (with color) SVG icons.
     * @type {?}
     */
    IconService.prototype._svgCachedDefinitions;
    /**
     * Default color settings.
     * @type {?}
     */
    IconService.prototype._twoToneColorPalette;
    /**
     * A url prefix so users can determine a static asset root.
     * @type {?}
     */
    IconService.prototype._assetsSource;
    /**
     * To note whether a request to an icon is under processing.
     * @type {?}
     */
    IconService.prototype._httpQueue;
    /** @type {?} */
    IconService.prototype._rendererFactory;
    /** @type {?} */
    IconService.prototype._handler;
    /** @type {?} */
    IconService.prototype._document;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFudC1kZXNpZ24vaWNvbnMtYW5ndWxhci8iLCJzb3VyY2VzIjpbImNvbXBvbmVudC9pY29uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBYSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RSxPQUFPLEVBQWMsRUFBRSxJQUFJLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFRN0QsT0FBTyxFQUNMLGlCQUFpQixFQUNqQixVQUFVLEVBQ1YsZ0JBQWdCLEVBQ2hCLFFBQVEsRUFDUixTQUFTLEVBQ1QsUUFBUSxFQUNSLGtCQUFrQixFQUNsQix5QkFBeUIsRUFDekIsZ0JBQWdCLEVBQ2pCLE1BQU0sVUFBVSxDQUFDOzs7O0FBRWxCLGlDQUVDOzs7SUFEQyx5QkFBc0M7O0FBR3hDO0lBc01FLHFCQUNZLGdCQUFrQyxFQUN0QixRQUFxQixFQUNILFNBQWM7UUFGNUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUN0QixhQUFRLEdBQVIsUUFBUSxDQUFhO1FBQ0gsY0FBUyxHQUFULFNBQVMsQ0FBSztRQXhNeEQsaUJBQVksR0FBYyxTQUFTLENBQUM7UUFLcEM7O1dBRUc7UUFDTyxvQkFBZSxHQUFHLElBQUksR0FBRyxFQUEwQixDQUFDO1FBRTlEOztXQUVHO1FBQ08sMEJBQXFCLEdBQUcsSUFBSSxHQUFHLEVBQWdDLENBQUM7UUFFMUU7O1dBRUc7UUFDTyx5QkFBb0IsR0FBd0I7WUFDcEQsWUFBWSxF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LENBQUM7WUFDSCxDQUFDO1FBQ0gsQ0FBQztRQUNELElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDekQsTUFBTSxDQUFDLEdBQUcsQ0FBQztJQUNiLENBQUM7Ozs7SUFFRCwyQkFBSzs7O0lBQUw7UUFDRSxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQy9CLENBQUM7O2dCQTlObUMsZ0JBQWdCO2dCQURqQyxXQUFXLHVCQW1PM0IsUUFBUTtnREFDUixRQUFRLFlBQUksTUFBTSxTQUFDLFFBQVE7O0lBT2hDLGtCQUFDO0NBQUEsQUFoTkQsSUFnTkM7U0FoTlksV0FBVzs7O0lBQ3RCLG1DQUFvQzs7SUFFcEMsZ0NBQStCOztJQUMvQiw0QkFBNEI7Ozs7O0lBSzVCLHNDQUE4RDs7Ozs7SUFLOUQsNENBQTBFOzs7OztJQUsxRSwyQ0FHRTs7Ozs7SUFLRixvQ0FBNkI7Ozs7O0lBSzdCLGlDQUFzRDs7SUF1S3BELHVDQUE0Qzs7SUFDNUMsK0JBQTJDOztJQUMzQyxnQ0FBc0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBIdHRwQ2xpZW50LCBIdHRwQmFja2VuZCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9wdGlvbmFsLCBJbmplY3QsIFJlbmRlcmVyMiwgUmVuZGVyZXJGYWN0b3J5MiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCBtYXAsIHNoYXJlLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBJY29uRGVmaW5pdGlvbixcbiAgQ2FjaGVkSWNvbkRlZmluaXRpb24sXG4gIFR3b1RvbmVDb2xvclBhbGV0dGUsXG4gIFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIsXG4gIFRoZW1lVHlwZVxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBnZXRTZWNvbmRhcnlDb2xvcixcbiAgd2l0aFN1ZmZpeCxcbiAgaXNJY29uRGVmaW5pdGlvbixcbiAgcHJpbnRFcnIsXG4gIHByaW50V2FybixcbiAgY2xvbmVTVkcsXG4gIHdpdGhTdWZmaXhBbmRDb2xvcixcbiAgZ2V0SWNvbkRlZmluaXRpb25Gcm9tQWJicixcbiAgcmVwbGFjZUZpbGxDb2xvclxufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVxSWNvblRhc2sge1xuICBvYjogT2JzZXJ2YWJsZTxJY29uRGVmaW5pdGlvbiB8IG51bGw+O1xufVxuXG5leHBvcnQgY2xhc3MgSWNvblNlcnZpY2Uge1xuICBkZWZhdWx0VGhlbWU6IFRoZW1lVHlwZSA9ICdvdXRsaW5lJztcblxuICBwcm90ZWN0ZWQgX3JlbmRlcmVyOiBSZW5kZXJlcjI7XG4gIHByb3RlY3RlZCBfaHR0cDogSHR0cENsaWVudDtcblxuICAvKipcbiAgICogUmVnaXN0ZXIgaWNvbnMuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3N2Z0RlZmluaXRpb25zID0gbmV3IE1hcDxzdHJpbmcsIEljb25EZWZpbml0aW9uPigpO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciByZW5kZXJlZCAod2l0aCBjb2xvcikgU1ZHIGljb25zLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9zdmdDYWNoZWREZWZpbml0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZWRJY29uRGVmaW5pdGlvbj4oKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBjb2xvciBzZXR0aW5ncy5cbiAgICovXG4gIHByb3RlY3RlZCBfdHdvVG9uZUNvbG9yUGFsZXR0ZTogVHdvVG9uZUNvbG9yUGFsZXR0ZSA9IHtcbiAgICBwcmltYXJ5Q29sb3IgIDogJyMzMzMzMzMnLFxuICAgIHNlY29uZGFyeUNvbG9yOiAnI0U2RTZFNidcbiAgfTtcblxuICAvKipcbiAgICogQSB1cmwgcHJlZml4IHNvIHVzZXJzIGNhbiBkZXRlcm1pbmUgYSBzdGF0aWMgYXNzZXQgcm9vdC5cbiAgICovXG4gIHByb3RlY3RlZCBfYXNzZXRzU291cmNlID0gJyc7XG5cbiAgLyoqXG4gICAqIFRvIG5vdGUgd2hldGhlciBhIHJlcXVlc3QgdG8gYW4gaWNvbiBpcyB1bmRlciBwcm9jZXNzaW5nLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9odHRwUXVldWUgPSBuZXcgTWFwPHN0cmluZywgUmVxSWNvblRhc2s+KCk7XG5cbiAgc2V0IHR3b1RvbmVDb2xvcih7IHByaW1hcnlDb2xvciwgc2Vjb25kYXJ5Q29sb3IgfTogVHdvVG9uZUNvbG9yUGFsZXR0ZVNldHRlcikge1xuICAgIGlmIChwcmltYXJ5Q29sb3IgJiYgdHlwZW9mIHByaW1hcnlDb2xvciA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHNlY29uZGFyeUNvbG9yID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc2Vjb25kYXJ5Q29sb3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnByaW1hcnlDb2xvciA9IHByaW1hcnlDb2xvcjtcbiAgICAgIHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUuc2Vjb25kYXJ5Q29sb3IgPSBzZWNvbmRhcnlDb2xvciB8fCBnZXRTZWNvbmRhcnlDb2xvcihwcmltYXJ5Q29sb3IpO1xuICAgIH1cbiAgfVxuXG4gIGdldCB0d29Ub25lQ29sb3IoKTogVHdvVG9uZUNvbG9yUGFsZXR0ZVNldHRlciB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5fdHdvVG9uZUNvbG9yUGFsZXR0ZSB9IGFzIFR3b1RvbmVDb2xvclBhbGV0dGU7IC8vIE1ha2UgYSBjb3B5IHRvIGF2b2lkIHVuZXhwZWN0ZWQgY2hhbmdlcy5cbiAgfVxuXG4gIGNoYW5nZUFzc2V0c1NvdXJjZShwcmVmaXg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuX2Fzc2V0c1NvdXJjZSA9IHByZWZpeC5lbmRzV2l0aCgnLycpID8gcHJlZml4IDogcHJlZml4ICsgJy8nO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIEljb25EZWZpbml0aW9uIHByb3ZpZGVkIGJ5IEFudCBEZXNpZ24sIHBhcnNpbmcgQWJzdHJhY3ROb2RlIHRvIHN2ZyBzdHJpbmcuXG4gICAqIEBwYXJhbSBpY29uc1xuICAgKi9cbiAgYWRkSWNvbiguLi5pY29uczogSWNvbkRlZmluaXRpb25bXSk6IHZvaWQge1xuICAgIHRoaXMuX2FkZEljb25MaXRlcmFsKC4uLmljb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBpY29uLlxuICAgKiBAcGFyYW0gaWNvbnMgSWNvbnMgdGhhdCB1c2VycyB3YW50IHRvIHVzZSBpbiB0aGVpciBwcm9qZWN0cy4gVXNlciBkZWZpbmVkIGljb25zIGFuZCBwcmVkZWZpbmVkXG4gICAqICAgaWNvbnMgcHJvdmlkZWQgYnkgYW50LWRlc2lnbiBzaG91bGQgaW1wbGVtZW50IEljb25EZWZpbml0aW9uIGJvdGguXG4gICAqL1xuICBwcm90ZWN0ZWQgX2FkZEljb25MaXRlcmFsKC4uLmljb25zOiBJY29uRGVmaW5pdGlvbltdKTogdm9pZCB7XG4gICAgaWNvbnMuZm9yRWFjaChpY29uID0+IHtcbiAgICAgIHRoaXMuX3N2Z0RlZmluaXRpb25zLnNldCh3aXRoU3VmZml4KGljb24ubmFtZSwgaWNvbi50aGVtZSksIGljb24pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9nZXQoa2V5OiBzdHJpbmcpOiBJY29uRGVmaW5pdGlvbiB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl9zdmdEZWZpbml0aW9ucy5nZXQoa2V5KSB8fCBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBzdGF0aWMgZmlsZSBhbmQgcmV0dXJuIGl0IGFzIGEgc3RyaW5nLCBjcmVhdGUgYSBJY29uRGVmaW5pdGlvbiBhbmQgY2FjaGUgaXQgb3IgcmV0dXJuIG51bGwuXG4gICAqL1xuICBwcm90ZWN0ZWQgX2dldEZyb21SZW1vdGUodXJsOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEljb25EZWZpbml0aW9uIHwgbnVsbD4ge1xuICAgIGlmICh0aGlzLl9odHRwKSB7XG4gICAgICBsZXQgdGFzayA9IHRoaXMuX2h0dHBRdWV1ZS5nZXQodXJsKTtcbiAgICAgIGxldCBvYjogT2JzZXJ2YWJsZTxJY29uRGVmaW5pdGlvbiB8IG51bGw+O1xuICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgb2IgPSB0YXNrLm9iO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2IgPSB0aGlzLl9jcmVhdGVPYnNlcnZhYmxlUmVxdWVzdCh1cmwpO1xuICAgICAgICB0YXNrID0geyBvYiB9O1xuICAgICAgICB0aGlzLl9odHRwUXVldWUuc2V0KHVybCwgdGFzayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByaW50V2FybignWW91IG5lZWQgdG8gaW1wb3J0IEh0dHBDbGllbnQgbW9kdWxlIHRvIHVzZSBkeW5hbWljIGltcG9ydGluZycpO1xuICAgICAgcmV0dXJuIG9ic2VydmFibGVPZihudWxsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jcmVhdGVPYnNlcnZhYmxlUmVxdWVzdCh1cmw6IHN0cmluZyk6IE9ic2VydmFibGU8SWNvbkRlZmluaXRpb24gfCBudWxsPiB7XG4gICAgY29uc3QgaWNvbjogSWNvbkRlZmluaXRpb24gPSBnZXRJY29uRGVmaW5pdGlvbkZyb21BYmJyKHVybCk7XG4gICAgcmV0dXJuIHRoaXMuX2h0dHAuZ2V0KFxuICAgICAgYCR7dGhpcy5fYXNzZXRzU291cmNlfWFzc2V0cy8ke2ljb24udGhlbWV9LyR7aWNvbi5uYW1lfS5zdmdgLFxuICAgICAgeyByZXNwb25zZVR5cGU6ICd0ZXh0JyB9XG4gICAgKS5waXBlKFxuICAgICAgc2hhcmUoKSwgLy8gVXNlIGBzaGFyZWAgc28gaWYgbXVsdGkgZGlyZWN0aXZlcyByZXF1ZXN0IHRoZSBzYW1lIGljb24sIEhUVFAgcmVxdWVzdCB3b3VsZCBvbmx5IGJlIGZpcmVkIG9uY2UuXG4gICAgICB0YXAoKCkgPT4gdGhpcy5faHR0cFF1ZXVlLmRlbGV0ZSh1cmwpKSxcbiAgICAgIG1hcChzdmdTdHJpbmcgPT4ge1xuICAgICAgICBpY29uLmljb24gPSBzdmdTdHJpbmc7XG4gICAgICAgIHRoaXMuX2FkZEljb25MaXRlcmFsKGljb24pO1xuICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgIH0pLFxuICAgICAgY2F0Y2hFcnJvcigoKSA9PiB7XG4gICAgICAgIHByaW50RXJyKGB0aGUgaWNvbiAke3VybH0gZG9lcyBub3QgZXhpc3QgaW4geW91ciBhc3NldHMgZm9sZGVyYCk7XG4gICAgICAgIHRoaXMuX2h0dHBRdWV1ZS5kZWxldGUodXJsKTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZihudWxsKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJY29uIGNvbXBvbmVudCB3b3VsZCBjYWxsIHRoaXMgbWV0aG9kIHRvIGdldCBhIFNWRyBlbGVtZW50LlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgT2JzZXJ2YWJsZSBTVkcgZWxlbWVudCBiZWNhdXNlIHdoZW4gdXNlciB3YW50cyB0byBnZXQgYW4gaWNvbiBkeW5hbWljYWxseSwgdGhhdCB3b3VsZCBiZSBhc3luYyxcbiAgICogc28gd2UgcHJvdmlkZWQgYSB1bmlmaWVkIGludGVyZmFjZSBoZXJlLlxuICAgKi9cbiAgZ2V0UmVuZGVyZWRDb250ZW50KGljb246IEljb25EZWZpbml0aW9uIHwgc3RyaW5nLCB0d29Ub25lQ29sb3I/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQgfCBudWxsPiB7XG4gICAgY29uc3QgZGVmaW5pdGlvbk9yTnVsbDogSWNvbkRlZmluaXRpb24gfCBudWxsID0gaXNJY29uRGVmaW5pdGlvbihpY29uKVxuICAgICAgPyBpY29uIGFzIEljb25EZWZpbml0aW9uXG4gICAgICA6IHRoaXMuX2dldChpY29uIGFzIHN0cmluZyk7XG4gICAgY29uc3QgJGljb24gPSBkZWZpbml0aW9uT3JOdWxsID8gb2JzZXJ2YWJsZU9mKGRlZmluaXRpb25Pck51bGwpIDogdGhpcy5fZ2V0RnJvbVJlbW90ZShpY29uIGFzIHN0cmluZyk7XG5cbiAgICByZXR1cm4gJGljb24ucGlwZShcbiAgICAgIG1hcChpID0+IHtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFNWR0Zyb21DYWNoZU9yQ3JlYXRlTmV3KGksIHR3b1RvbmVDb2xvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpbnRFcnIoYHRoZSBpY29uICR7aWNvbn0gZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IHJlZ2lzdGVyZWRgKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9sb2FkU1ZHRnJvbUNhY2hlT3JDcmVhdGVOZXcoaWNvbjogSWNvbkRlZmluaXRpb24sIHR3b1RvbmVDb2xvcj86IHN0cmluZyk6IFNWR0VsZW1lbnQge1xuICAgIGxldCBzdmc6IFNWR0VsZW1lbnQ7XG4gICAgY29uc3QgcHJpID0gdHdvVG9uZUNvbG9yIHx8IHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUucHJpbWFyeUNvbG9yO1xuICAgIGNvbnN0IHNlYyA9IGdldFNlY29uZGFyeUNvbG9yKHByaSkgfHwgdGhpcy5fdHdvVG9uZUNvbG9yUGFsZXR0ZS5zZWNvbmRhcnlDb2xvcjtcbiAgICBjb25zdCBrZXkgPSB3aXRoU3VmZml4QW5kQ29sb3IoaWNvbi5uYW1lLCBpY29uLnRoZW1lLCBwcmksIHNlYyk7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fc3ZnQ2FjaGVkRGVmaW5pdGlvbnMuZ2V0KGtleSk7XG5cbiAgICAvLyBJZiB0aGlzIGljb24gaXMgdXNlZCBiZWZvcmUsIHRoZXJlIHNob3VsZCBiZSBhIGNvcHkgaW4gY2FjaGVkRGVmaW5pdGlvbnMsIGp1c3QgY29weSBpdC5cbiAgICAvLyBPdGhlcndpc2UsIGdlbmVyYXRlIG9uZSBmcm9tIHN0cmluZyBvciBTVkcgZWxlbWVudCwgYW5kIGNhY2hlIGl0LlxuICAgIGlmICghY2FjaGVkKSB7XG4gICAgICBzdmcgPSB0aGlzLl9zZXRTVkdBdHRyaWJ1dGUodGhpcy5fY29sb3JpemVTVkdJY29uKFxuICAgICAgICB0eXBlb2YgaWNvbi5pY29uID09PSAnc3RyaW5nJyA/IHRoaXMuX2NyZWF0ZVNWR0VsZW1lbnRGcm9tU3RyaW5nKGljb24uaWNvbikgOiBpY29uLmljb24sXG4gICAgICAgIGljb24udGhlbWUgPT09ICd0d290b25lJyxcbiAgICAgICAgcHJpLFxuICAgICAgICBzZWNcbiAgICAgICkpO1xuICAgICAgdGhpcy5fc3ZnQ2FjaGVkRGVmaW5pdGlvbnMuc2V0KGtleSwgeyAuLi5pY29uLCBpY29uOiBzdmcgfSBhcyBDYWNoZWRJY29uRGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN2ZyA9IGNhY2hlZC5pY29uO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZVNWRyhzdmcpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jcmVhdGVTVkdFbGVtZW50RnJvbVN0cmluZyhzdHI6IHN0cmluZyk6IFNWR0VsZW1lbnQge1xuICAgIGNvbnN0IGNvbG9yUGFyc2VkID0gcmVwbGFjZUZpbGxDb2xvcihzdHIpO1xuICAgIGNvbnN0IGRpdiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRpdi5pbm5lckhUTUwgPSBjb2xvclBhcnNlZDtcbiAgICBjb25zdCBzdmc6IFNWR0VsZW1lbnQgPSBkaXYucXVlcnlTZWxlY3Rvcignc3ZnJyk7XG4gICAgaWYgKCFzdmcpIHtcbiAgICAgIHRocm93IEVycm9yKCc8c3ZnPiB0YWcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBzdmc7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3NldFNWR0F0dHJpYnV0ZShzdmc6IFNWR0VsZW1lbnQpOiBTVkdFbGVtZW50IHtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3ZnLCAnd2lkdGgnLCAnMWVtJyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHN2ZywgJ2hlaWdodCcsICcxZW0nKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb2xvcml6ZVNWR0ljb24oc3ZnOiBTVkdFbGVtZW50LCB0d290b25lOiBib29sZWFuLCBwcmk6IHN0cmluZywgc2VjOiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICBpZiAodHdvdG9uZSkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzdmcuY2hpbGROb2RlcztcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQ6IEhUTUxFbGVtZW50ID0gY2hpbGRyZW5bIGkgXSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZSgnZmlsbCcpID09PSAnc2Vjb25kYXJ5Q29sb3InKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGNoaWxkLCAnZmlsbCcsIHNlYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGNoaWxkLCAnZmlsbCcsIHByaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHN2ZywgJ2ZpbGwnLCAnY3VycmVudENvbG9yJyk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuX3N2Z0RlZmluaXRpb25zLmNsZWFyKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgX3JlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5MixcbiAgICBAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgX2hhbmRsZXI6IEh0dHBCYWNrZW5kLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRE9DVU1FTlQpIHByb3RlY3RlZCBfZG9jdW1lbnQ6IGFueVxuICApIHtcbiAgICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcbiAgICBpZiAodGhpcy5faGFuZGxlcikge1xuICAgICAgdGhpcy5faHR0cCA9IG5ldyBIdHRwQ2xpZW50KHRoaXMuX2hhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuIl19